<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v6.js"></script>
<script src="https://unpkg.com/topojson@3"></script>

<!-- Create an element where the map will take place -->

<head>
    <h1> A day in the life of the US electricity system </h1>
</head>

<body>
    <p> Here's some lead in text to the overall graphic</p>
    <p> Here's some more lead in text</p>
    <div>
        <h2> Total US Hourly Generation by Energy Source</h2>
        <p> Here's lead in to the first graphic </p>
        <p> Maybe more lead in to this one</p>
        <svg id="stack_bar" width="1050" height="200"></svg>
    </div>

    <div>
        <h2> Hourly Generation by Generator</h2>
        <p> Here's lead in to the second graphic </p>
        <svg id="dot_map" width="1050" height="500"></svg>

    </div>
</body>

<script>
    // set the dimensions and margins of the graph
    const margin = {
            top: 10,
            right: 150,
            bottom: 30,
            left: 80
        },
        width1 = 900 - margin.left - margin.right,
        height1 = 200 - margin.top - margin.bottom;

    // append the svg object to the body of the page
    const svg1 = d3.select("#stack_bar")
        .append("svg")
        .attr("width", width1 + margin.left + margin.right)
        .attr("height", height1 + margin.top + margin.bottom)
        .append("g")
        .attr("transform",
            `translate(${margin.left}, ${margin.top})`);

    // Stack the data: each group will be represented on top of each other
    let energy_sources = [
        "coal",
        "hydroelectric",
        "natural_gas",
        "nuclear",
        "other",
        "petroleum",
        "solar",
        "wind"
    ]
    let energy_colors = [
        "black",
        "lightblue",
        "brown",
        "lightgreen",
        "grey",
        "purple",
        "yellow",
        "blue"
    ]

    //Read the data
    d3.csv("total_us_gen_summer.csv").then(function(data) {

        // group the data: one array for each value of the X axis.
        // data_filtered = data.filter(d => +d.hour <= HOUR);
        var sumstat = d3.group(data, d => d.hour);

        // Stack the data: each group will be represented on top of each other
        const mygroups = energy_sources // list of group names
        const mygroup = [0, 1, 2, 3, 4, 5, 6, 7] // list of group names

        var stackedData = d3.stack()
            .keys(mygroup)
            .value(function(d, key) {
                return d[1][key].gen_mw
            })
            (sumstat)

        // Add X axis it is a date format
        const x = d3.scaleLinear()
            .domain(d3.extent(data, d => +d.hour))
            .range([0, width1]);

        svg1.append("g")
            .attr("transform", `translate(0, ${height1})`)
            .call(d3.axisBottom(x).ticks());

        // Add Y axis
        const y = d3.scaleLinear()
            // .domain([0, Math.max(data, d => +d.gen_mw) * 1.2])
            .domain([0, 700000])
            .range([height1, 0]);

        svg1.append("g")
            .call(d3.axisLeft(y).ticks(5));

        // color palette
        const color = d3.scaleOrdinal()
            .domain(mygroups)
            .range(energy_colors)

        //Add legend
        add_leg_entry = function(y1, fill, text) {
            svg1.append("rect")
                .attr("class", "legend")
                .attr("x", width1 + 10)
                .attr("y", y1)
                .attr("width", 10)
                .attr("height", 10)
                .attr("fill", fill)
                .attr("stroke", "black")


            svg1.append("text")
                .attr("class", "legend-text")
                .attr("x", width1 + 30)
                .attr("y", y1 + 10)
                .text(text)
                .attr("fill", "black")
        }
        let start_pos = 10;
        for (let i = 1; i < energy_sources.length + 1; i++) {
            j = energy_sources.length - i;
            add_leg_entry(start_pos, energy_colors[j], energy_sources[j])
            start_pos += 20
        }

        area = d3.area()
            .x(d => x(Math.min(d.data[0], HOUR)))
            .y0(d => y(d[0]))
            .y1(d => y(d[1]))

        // Show the areas
        let layers = svg1
            .selectAll("layers")
            .data(stackedData)
            .join("path")
            .attr("class", d => "p-" + d.key)
            .style("fill", d => color(mygroups[d.key]))
            // .attr("d", area)

        var hour = 0;
        let func = function(e) {
            hour++;
            if (hour > 24) {
                hour = 0;
            }
            area = d3.area()
                .x(d => x(Math.min(d.data[0], hour)))
                .y0(d => y(d[0]))
                .y1(d => y(d[1]))

            layers
                .transition()
                .duration(700)
                .ease(d3.easeLinear)
                .attr("d", area)
        }
        var timer = d3.interval(func, 1500);

    })
</script>

<script>
    // The svg
    let svg = d3.select("#dot_map"),
        width2 = +svg.attr("width"),
        height2 = +svg.attr("height");

    // Map and projection
    let myprojection = d3.geoAlbersUsa()
        //.scale(85)
        //.translate([width / 2, height / 2 * 1.3])

    // A path generator
    let path = d3.geoPath()
        .projection(myprojection)


    // Load world shape AND list of connection
    Promise.all([
        d3.json("plant_by_hour_v3.json"), // currently one date in july
        // d3.json("powerplants.json"), //ba locations
        d3.json("states.json")
    ]).then(ready)

    function ready(res) {

        let plant_location = res[0] // the json
        let states = topojson.feature(res[1], res[1].objects.states)

        let r_denom = 2.5;


        // states 
        // TODO: Switch to regional boundaries
        //TODO: highlight based on demand?
        let borders = svg.append("g")
            .selectAll("path")
            .data(states.features)
            .join("path")
            .attr("fill", "lightgrey")
            .attr("d", path)
            .style("stroke", "black")
            .style("stroke-width", 1)
            .style("opacity", 0.5)

        // TODO: Map colors in more js way - see healthcare chart

        // color palette
        const color = d3.scaleOrdinal()
            .domain(energy_sources)
            .range(energy_colors)

        // BA centroids
        let plants = svg
            .selectAll(".plants")
            .data(plant_location.features)
            .join("circle")
            // .attr("class", d => "p-" + d.properties.BA_code) // Give circles a class name.
            .attr("cx", function(d) {
                return path.centroid(d)[0]
            })
            .attr("cy", function(d) {
                return path.centroid(d)[1]
            })
            .attr("r", d => Math.sqrt(d.properties.hour_1) / r_denom)
            .style("stroke", "grey")
            .style("fill", d => color(d.properties.PrimSource))
            .style("opacity", d => {
                if (d.properties.PrimSource == "solar" || d.properties.PrimSource == "wind") {
                    return 0.9
                } else {
                    return 0.4
                }
            })
            .style("stroke", d => {
                if (d.properties.PrimSource == "solar" || d.properties.PrimSource == "wind") {
                    return "black"
                } else {
                    return "grey"
                }
            })
            .style("stroke-width", d => {
                if (d.properties.PrimSource == "solar" || d.properties.PrimSource == "wind") {
                    return 0.9
                } else {
                    return 0.4
                }
            });

        let hour = 0;
        let func = function(e) {
            hour++;
            if (hour > 24) {
                hour = 1;
            }

            hour_string = `hour_${hour}`;
            plants
                .transition()
                .duration(700)
                .ease(d3.easeLinear)
                .attr("r", d => Math.sqrt(d.properties[hour_string]) / r_denom);
        }
        var timer = d3.interval(func, 1500);
    }
</script>