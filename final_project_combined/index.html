<!DOCTYPE html>

<!-- https://flatuicolors.com/palette/au -->

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v6.js"></script>
<script src="https://unpkg.com/topojson@3"></script>
<script src="https://unpkg.com/d3-simple-slider"></script>
<script src="https://rawgit.com/susielu/d3-annotation/master/d3-annotation.min.js"></script>



<!-- Create an element where the map will take place -->

<head>
    <meta charset="utf-8">
    <style>
        body {
            max-width: 1050px;
            /*margin: 10px auto 10px auto;
            margin: 10px auto;*/
            margin: 0 auto;
            font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
        }
        
        .chart-container {
            max-width: 1050px;
            margin: 0 auto;
            font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
        }
        
        .overlap {
            margin: -100px, -100px, -100px, -100px;
        }
        
        p {
            /* text-align: center; */
            font-family: 'Arial';
            font-size: 15px;
        }
        
        svg {
            /* background-color: darkblue; */
            overflow: visible;
        }
        
        h1 {
            /* border: 4px solid green; */
        }
        
        .pop-up {
            position: absolute;
            border: 1px solid black;
            border-radius: 1px;
            line-height: 1.2;
            width: 100;
            pointer-events: none;
            background-color: white;
            padding: 10px;
            font-size: 14px;
            font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
        }
        
        .pop-up-itx {
            position: absolute;
            border: 1px solid black;
            border-radius: 1px;
            line-height: 1.2;
            width: 100;
            pointer-events: none;
            background-color: white;
            padding: 10px;
            font-size: 14px;
            font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
        }
        
        .hour-slider {
            top: 0;
            left: 0;
            margin: 0 auto;
        }
        
        .note {
            font-size: 12px
        }
        
        .annotation {
            font-size: 12px;
            font-family: "arial";
        }
        
        .hour_of_day {
            font-size: 20px;
            margin-left: 250px;
        }
    </style>
</head>

<body>
    <h1> A day in the life of the US electricity system </h1>
    <p> </p>
    <div class="chart-container">
        <h2> Electricity generation varies substantially by hour and location</h2>
        <p> During one day last summer (July 20th, 2021), several thousand different generators contributed to meet US demand. Demand changes significantly througout the day, and so does the output of different generators. <b>Wind</b> and <b>solar</b> generation
            are intermittent sources; they depend on the weather. Many sources, like <b>hydropower</b> and <b>nuclear</b>, serve as baseload, and do not fluctuate much throughout the day. <b>Coal</b> and <b>Natural Gas</b> include both baseload generators
            and "peaking" plants, which can help meet spikes in demand, or gaps in renewable supply. </p>
        <h3 class="hour_of_day"></h3>
        <svg id="dot_map" width="850" height="550"></svg>

        <svg id="stack_bar" width="150" height="150"></svg>

        <!-- TIME SLIDER HERE -->
        <div class="hour-slider">
            <!-- <div class="col-sm-2">
                <p id="value-step"></p>
            </div> -->
            <div class="col-sm">
                <div id="slider-step"></div>
            </div>
        </div>

        <p class="note">Note: Hourly electricity data by source type (e.g., wind, solar) obtained at the regional (Balancing Authority) level from EIA. Plant-level generation is estimated by multiplying hour/source level generation by the proportion of prior year generation
            in the region by the specific plant.</p>
    </div>



    <div class="chart-container">
        <h2> The grid adapts by trading electricity between different Balancing Authorities</h2>
        <p> The US grid contains 68 different Balancing Authorities, or regional electricity grid operators. Each balancing authority must ensure that supply meets demand for all people within the region for a given hour. Interchange between regions allows
            excess supply in one region to meet demand in another region. Depending on the hour, if the sun is shining, or the wind is blowing, a region might send and/or receive electricity from a dozen other regions.</p>
        <svg id="energy_flows" width="1050" height="500"></svg>

    </div>
    <div class="spacer">
        <h2></h2>
    </div>

    <div class="pop-up">
    </div>

</body>

<script>
    // OVERALL SETUP
    const HOUR_TRANS_TIME = 500;

    // Define first headline
    let hed = d3.select(".hour_of_day")
    hed.html("Electricity generation by source at 1 AM ET")

    ///// STACK BAR SETUP ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // set the dimensions and margins of the graph
    const margin1 = {
            top: -150,
            right: 50,
            bottom: 150,
            left: -120
        },
        width1 = 150 - margin1.left - margin1.right,
        height1 = 150 - margin1.top - margin1.bottom;

    // append the svg object to the body of the page
    const svg1 = d3.select("#stack_bar")
        .append("svg")
        .attr("width", width1 + margin1.left + margin1.right)
        .attr("height", height1 + margin1.top + margin1.bottom)
        .append("g")
        .attr("transform",
            `translate(${margin1.left}, ${margin1.top})`);

    // Stack the data: each group will be represented on top of each other
    let energy_sources = [
        "coal",
        "hydroelectric",
        "natural_gas",
        "nuclear",
        "other",
        "petroleum",
        "solar",
        "wind"
    ]
    let source_labels = [
        "Coal",
        "Hydroelectric",
        "Natural Gas",
        "Nuclear",
        "Other",
        "Petroleum",
        "Solar",
        "Wind"
    ]
    let energy_colors = [
        "#686de0", //coal
        "#22a6b3", //hydro
        "#30336b", //gas
        "#badc58", //nuclear
        "#535c68", //other
        "#535c68", //petrol
        "#f9ca24", //solar
        "#e056fd" //wind
    ]

    ////////////////// DOT MAP SETUP /////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Features of the annotation
    const annotations = [{
        note: {
            label: "Solar increases from zero to generate over a third of all power in early afternoon in Southern California."
        },
        x: 60,
        y: 320,
        dy: 50,
        dx: -50
    }, {
        note: {
            label: "Wind varies less predictably throughout the day, but supplies less energy during the middle of the day."
        },
        x: 300,
        y: 400,
        dy: 50,
        dx: -50
    }]

    // Add annotation to the chart
    const makeAnnotations = d3.annotation()
        .annotations(annotations)
    d3.select("#dot_map")
        .append("g")
        .attr("class", "annotation")
        .call(makeAnnotations)



    // set the dimensions and margins of the graph
    const margin2 = {
            top: 0,
            right: 0,
            bottom: 0,
            left: -100
        },
        width2 = 800 - margin2.left - margin2.right,
        height2 = 800 - margin2.top - margin2.bottom;

    // append the svg object to the body of the page
    const svg2 = d3.select("#dot_map")
        .append("svg")
        .attr("width", width2 + margin2.left + margin2.right)
        .attr("height", height2 + margin2.top + margin2.bottom)
        .append("g")
        .attr("transform",
            `translate(${margin2.left}, ${margin2.top})`);

    // // The svg
    // let svg2 = d3.select("#dot_map"),
    //     width2 = +svg2.attr("width"),
    //     height2 = +svg2.attr("height");

    // // Map and projection
    let albers_us_projection = d3.geoAlbersUsa()

    // A path generator
    let geo_path = d3.geoPath()
        .projection(albers_us_projection)

    //Read the data
    // d3.csv("total_us_gen_summer.csv").then(function(data) {

    //////////////// ENERGY ARCS SETUP ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
    let svg3 = d3.select("#energy_flows"),
        width = +svg3.attr("width"),
        height = +svg3.attr("height");


    // load all layers
    Promise.all([
        d3.json("ba_points.json"), //ba locations
        d3.csv("seasonal_intx_geo.csv"),
        d3.json("ba_boundaries.json"),
        d3.json("states_L48.json"),
        d3.csv("total_us_gen_summer.csv"),
        d3.json("plant_by_hour_v3.json") // currently one date in july

    ]).then(ready)

    function ready(res) {

        national_total = res[4]

        // group the data: one array for each value of the X axis.
        // data_filtered = data.filter(d => +d.hour <= HOUR);
        var sumstat = d3.group(national_total, d => d.hour);

        // Stack the data: each group will be represented on top of each other
        const mygroups = energy_sources // list of group names
        const mygroup = [0, 1, 2, 3, 4, 5, 6, 7] // list of group names

        var stackedData = d3.stack()
            .keys(mygroup)
            .value(function(d, key) {
                return d[1][key].gen_mw
            })
            (sumstat)

        // Add X axis it is a date format
        const x = d3.scaleLinear()
            .domain(d3.extent(national_total, d => +d.hour))
            .range([0, width1]);

        function int_to_time_text(d) {
            if (d < 12) {
                return d + " AM"
            } else if (d == 12) {
                return "12 PM"
            } else if (d == 24) {
                return "12 AM"
            } else {
                return d - 12 + " PM"
            }
        }

        svg1.append("g")
            .attr("transform", `translate(0, ${height1})`)
            .call(d3.axisBottom(x)
                .ticks(7)
                .tickFormat(d => int_to_time_text(d)));

        // Add Y axis
        const y = d3.scaleLinear()
            // .domain([0, Math.max(data, d => +d.gen_mw) * 1.2])
            .domain([0, 700000])
            .range([height1, 0]);

        y_labels = ["", "100", "200", "300", "400", "500", "600", "700,000 megawatthours"]

        svg1.append("g")
            .attr("transform", `translate(${width1},0 )`)
            .call(d3.axisRight(y)
                .ticks(5)
                .tickFormat((d, i) => y_labels[i]))

        // color palette
        const color = d3.scaleOrdinal()
            .domain(mygroups)
            .range(energy_colors)

        // //Add legend
        // add_leg_entry = function(y1, fill, text) {
        //     svg1.append("rect")
        //         .attr("class", "legend")
        //         .attr("x", 0)
        //         .attr("y", y1)
        //         .attr("width", 10)
        //         .attr("height", 10)
        //         .attr("fill", fill)
        //         .attr("stroke", "black")


        //     svg1.append("text")
        //         .attr("class", "legend-text")
        //         .attr("x", 20)
        //         .attr("y", y1 + 10)
        //         .text(text)
        //         .attr("fill", "black")
        // }
        // let start_pos = -200;
        // for (let i = 1; i < energy_sources.length + 1; i++) {
        //     j = energy_sources.length - i;
        //     add_leg_entry(start_pos, energy_colors[j], source_labels[j])
        //     start_pos += 20
        // }

        area = d3.area()
            .x(d => x(Math.min(d.data[0], HOUR)))
            .y0(d => y(d[0]))
            .y1(d => y(d[1]))


        // Show the areas
        let layers = svg1
            .selectAll("layers")
            .data(stackedData)
            .join("path")
            .attr("class", d => "p-" + d.key)
            .style("fill", d => color(mygroups[d.key]))
            // .style("opacity", d => if_renew_then(d, 1, 0.5))
            // .attr("d", area)



        function update_area(hour) {
            hour_string = int_to_time_text(hour)
            lang = "Electricity generation by source at " + hour_string + " ET"
            hed.html(lang)

            area = d3.area()
                .x(d => x(Math.min(d.data[0], hour)))
                .y0(d => y(d[0]))
                .y1(d => y(d[1]))

            layers
                .transition()
                .duration(HOUR_TRANS_TIME)
                .ease(d3.easeLinear)
                .attr("d", area)
        }

        // var timer = d3.interval(func, 700);



        // })


        function int_to_time_text(d) {
            if (d < 12) {
                return d + " AM"
            } else if (d == 12) {
                return "12 PM"
            } else if (d == 24) {
                return "12 AM"
            } else {
                return d - 12 + " PM"
            }
        }




        ///// DOT MAP /////////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////////////////////




        // // Load world shape AND list of connection
        // Promise.all([
        //     d3.json("plant_by_hour_v3.json"), // currently one date in july
        //     d3.json("states_L48.json")
        // ]).then(ready)

        // function ready(res) {

        let plant_location = res[5] // the json
        let states = topojson.feature(res[3], res[3].objects.states)

        let r_denom = 4.5;

        // states 
        // TODO: Switch to regional boundaries
        //TODO: highlight based on demand?
        let state_borders_dot_map = svg2.append("g")
            .selectAll("path")
            .data(states.features)
            .join("path")
            .attr("fill", "lightgrey")
            .attr("d", geo_path)
            .style("stroke", "black")
            .style("stroke-width", 1)
            .style("opacity", 0.5)

        // TODO: Map colors in more js way - see healthcare chart

        // color palette
        // const color = d3.scaleOrdinal()
        //     .domain(energy_sources)
        //     .range(energy_colors)



        function if_renew_then(d, return1, return2) {
            if (d.properties.PrimSource == "solar" || d.properties.PrimSource == "wind") {
                return return1
            } else {
                return return2
            }
        }

        function apply_orig_plant_properties(plants) {
            plants
                .style("fill", d => color(d.properties.PrimSource))
                .style("opacity", d => if_renew_then(d, 0.9, .6))
                .style("stroke", d => if_renew_then(d, "black", "black"))
                .style("stroke-width", d => if_renew_then(d, 0.9, 0.4))
        }

        // BA centroids
        let plants = svg2
            .selectAll(".plants")
            .data(plant_location.features)
            .join("circle")
            .attr("class", d => "plant-" + d.properties.Plant_Code) // Give circles a class name.
            .attr("cx", d => geo_path.centroid(d)[0])
            .attr("cy", d => geo_path.centroid(d)[1])
            .attr("r", d => Math.sqrt(d.properties.hour_1 / r_denom))

        apply_orig_plant_properties(plants)


        mw_list = [1500, 1000, 500, 100]
        txt_list = ["1,500 MW", "1,000 MW", "500 MW", "100 MW"]
            //     //Add legend
            // add_leg_entry = function(start_pos, r, text) {
            //     svg2.append("circle")
            //         .attr("class", "legend")
            //         .attr("cx", width2 - 150)
            //         .attr("cy", start_pos)
            //         .attr("r", Math.sqrt(r / r_denom))
            //         .attr("fill", "lightgrey")
            //         .attr("stroke", "black")


        //     svg2.append("text")
        //         .attr("class", "legend-text")
        //         .attr("x", width2 - 128)
        //         .attr("y", start_pos + 5)
        //         .text(text)
        //         .attr("fill", "black")
        // }
        // let start_pos = 300;
        // for (let i = 0; i < mw_list.length; i++) {
        //     add_leg_entry(start_pos, mw_list[i], txt_list[i])
        //     start_pos += 40
        // }

        // let hour = 0;
        // let func = function(e) {
        //         hour++;
        //         if (hour > 24) {
        //             hour = 1;
        //         }

        function update_plants(hour) {
            hour_string = `hour_${hour}`;
            plants
                .transition()
                .duration(HOUR_TRANS_TIME)
                .ease(d3.easeLinear)
                .attr("r", d => Math.sqrt(d.properties[hour_string] / r_denom));
        }
        // var timer = d3.interval(func, 1000);

        let popup_plant_info = d3.select(".pop-up");

        // Mouseover plants to see more info
        plants.on("mouseover", (event, d) => {

            // timer.stop()

            //select borders
            svg2.selectAll(".plant-" + d.properties.Plant_Code)
                .style("fill", "lightblue")
                .style("fill-opacity", 1)
                .style("stroke", "black")
                .style("stroke-width", 1)

            // Construct the sentence that will popup
            let lang = d.properties.BA_code + "Plant id:" + d.properties.Plant_Code

            popup_plant_info
                .style("opacity", 1)
                .style("left", (event.x - 50) + "px")
                .style("top", (event.y - 75) + "px")
                .html(lang)

        })
        plants.on("mouseout", (event, d) => {

            apply_orig_plant_properties(plants)

            popup_plant_info
                .style("opacity", 0)

        })


        // <!-- ENERGY ARCS ---------------------------------------------- -->

        // The svg

        const ARC_COLOR = "#4834d4";
        const ARC_OPACTIY = 0.3
        const REGION_COLOR = "#7ed6df"
        const FLOWS_HOUR = "SUM_15"


        let ba_location = res[0] // the json
        let interchange = res[1] // the csv
        let control_areas = topojson.feature(res[2], res[2].objects.ba_boundaries)

        seasons = ['SPR', 'SUM', 'FAL', 'WIN']

        // Reformat the list of link. Note that columns in csv file are labeled
        const link = []
        interchange.forEach(function(row) {
            source = [+row["lon1"], +row["lat1"]]
            target = [+row["lon2"], +row["lat2"]]
            value_array = []
            for (let i = 0; i < seasons.length; i++) {
                for (let j = 0; j < 24; j++) {
                    value_array.push(row[seasons[i] + "_" + j])
                }
            }
            topush = {
                type: "LineString",
                coordinates: [source, target],
                value: value_array, // Add the value to weight the lines
                ba1: [row.ba1]
            }
            link.push(topush)
        })
        let popup_intx = d3.select(".pop-up");

        // States
        let state_background = svg3.append("g")
            .selectAll("path")
            .data(states.features)
            .join("path")
            .attr("fill", "lightgrey")
            .attr("fill-opacity", 0.3)
            .attr("d", geo_path)
            .style("stroke", "none")
            .style("stroke-width", .5)

        // Control Area borders
        let borders = svg3.append("g")
            .selectAll("path")
            .data(control_areas.features)
            .join("path")
            .attr("class", d => "border-" + d.properties.BA_code)
            .attr("fill", "none")
            .attr("d", geo_path)
            .style("stroke", "black")
            .style("stroke-width", 0.4)

        // Energy arcs
        let arcs = svg3.append("g")
            .selectAll("myPath")
            .data(link)
            .join("path")
            .attr("class", d => "arc-" + d.ba1)
            .attr("d", d => geo_path(d))
            .style("fill", "none")
            .style("stroke-width", 3)
            .style("stroke", ARC_COLOR)
            .style("opacity", ARC_OPACTIY)

        function if_inflow_then_x(d, hour, return1, return2) {
            if (+d[hour] < 0) {
                return return1
            } else {
                return return2
            }
        }

        // point flows
        let ba_itx_points = svg3
            .selectAll(".itx_points")
            .data(interchange)
            .join("circle")
            .attr("class", d => "itx-" + d.ba1)
            .attr("cx", d => if_inflow_then_x(d, FLOWS_HOUR,
                albers_us_projection([+d.lon2, +d.lat2])[0],
                albers_us_projection([+d.lon1, +d.lat1])[0]))
            .attr("cy", d => if_inflow_then_x(d, FLOWS_HOUR,
                albers_us_projection([+d.lon2, +d.lat2])[1],
                albers_us_projection([+d.lon1, +d.lat1])[1]))
            .style("fill", "none")
            .style("opacity", 0.8)
            .attr("r", 5)

        // // BA centroids
        let ba_points = svg3
            .selectAll(".ba_points")
            .data(ba_location.features)
            .join("circle")
            .attr("class", d => "point-" + d.properties.BA_code) // Give circles a class name.
            .attr("cx", d => geo_path.centroid(d)[0])
            .attr("cy", d => geo_path.centroid(d)[1])
            .attr("r", 5)
            .style("stroke", "black")
            .style("fill", "grey")

        // // stop loop if mouseover any elements
        // arcs.on("mouseover", (event, d) => {
        //     timer.stop()
        // })

        // Mouseover centroid to see in/outflow
        ba_points.on("mouseover", (event, d) => {
            console.log({
                    event
                })
                // timer.stop()

            //select borders
            svg3.select(".border-" + d.properties.BA_code)
                .style("fill", REGION_COLOR)
                .style("fill-opacity", .5)
                .style("stroke-width", 1)

            arcs
                .style("opacity", .2)

            // Construct the sentence that will popup
            let lang = d.properties.NAME;

            popup_intx
                .style("opacity", 1)
                .style("left", (event.x) + "px")
                .style("top", (event.y + 350) + "px")
                .html(lang)

            //select centroid
            svg3.select(".point-" + d.properties.BA_code)
                .style("fill", "grey")
                .style("stroke", "black")
                .style("opacity", 0.2)
                .attr("r", 10)

            //arcs
            svg3.selectAll(".arc-" + d.properties.BA_code)
                .style("opacity", 1)

            //flows
            svg3.selectAll(".itx-" + d.properties.BA_code)
                .transition()
                .duration(1500)
                .ease(d3.easeLinear)
                .attr("cx", d => if_inflow_then_x(d, FLOWS_HOUR,
                    albers_us_projection([+d.lon1, +d.lat1])[0],
                    albers_us_projection([+d.lon2, +d.lat2])[0]))
                .attr("cy", d => if_inflow_then_x(d, FLOWS_HOUR,
                    albers_us_projection([+d.lon1, +d.lat1])[1],
                    albers_us_projection([+d.lon2, +d.lat2])[1]))
                .style("stroke", "black")
                .style("fill", d => if_inflow_then_x(d, FLOWS_HOUR, "#0092ff", "#ff8100"))
                .style("opacity", 0.8)
                .attr("r", d => Math.sqrt(Math.abs(+d[FLOWS_HOUR])) / 2)

        })
        ba_points.on("mouseout", (event, d) => {
            arcs
                .style("opacity", ARC_OPACTIY)
                .style("stroke", ARC_COLOR)

            borders
                .style("fill", "none")
                .style("stroke-width", 0.4)

            // Move flows back to original locations
            svg3.selectAll(".itx-" + d.properties.BA_code)
                .transition()
                .attr("cx", d => if_inflow_then_x(d, FLOWS_HOUR,
                    albers_us_projection([+d.lon2, +d.lat2])[0],
                    albers_us_projection([+d.lon1, +d.lat1])[0]))
                .attr("cy", d => if_inflow_then_x(d, FLOWS_HOUR,
                    albers_us_projection([+d.lon2, +d.lat2])[1],
                    albers_us_projection([+d.lon1, +d.lat1])[1]))
                .style("fill", "none")
                .style("stroke", "none")
                .attr("r", 5)

            ba_points
                .style("fill", "grey")
                .style("opacity", 1)
                .attr("r", 5)

            popup_intx
                .style("opacity", 0)

        })


        // let hour = 1;
        // let func = function(e) {
        // if (hour > 24) {
        //     hour = 1;
        // }
        // function update_flows(hour) {
        //     hour_string = `WIN_${hour}`;

        //     // move position
        //     ba_itx_points
        //         .transition()
        //         .duration(HOUR_TRANS_TIME)
        //         .ease(d3.easeLinear)
        //         .attr("cx", d => if_inflow_then_x(d, hour_string,
        //             albers_us_projection([+d.lon1, +d.lat1])[0],
        //             albers_us_projection([+d.lon2, +d.lat2])[0]))
        //         .attr("cy", d => if_inflow_then_x(d, hour_string,
        //             albers_us_projection([+d.lon1, +d.lat1])[1],
        //             albers_us_projection([+d.lon2, +d.lat2])[1]))
        //         // only show one direction of flows
        //         .style("fill", d => if_inflow_then_x(d, hour_string, "green", "none"))
        //         .attr("r", d => Math.sqrt(Math.abs(+d[hour_string])) / 2)
        //         .style("stroke", d => if_inflow_then_x(d, hour_string, "black", "none"))

        //     // Pause here
        //     .transition()
        //         .duration(1000)
        //         .ease(d3.easeLinear)

        //     // return to original
        //     .transition()
        //         .duration(100)
        //         .ease(d3.easeLinear)
        //         .attr("cx", d => if_inflow_then_x(d, hour_string,
        //             albers_us_projection([+d.lon2, +d.lat2])[0],
        //             albers_us_projection([+d.lon1, +d.lat1])[0]))
        //         .attr("cy", d => if_inflow_then_x(d, hour_string,
        //             albers_us_projection([+d.lon2, +d.lat2])[1],
        //             albers_us_projection([+d.lon1, +d.lat1])[1]))
        //         .style("fill", "none")
        //         .style("stroke", "none")

        // hour++;
        // }
        // var timer = d3.interval(func, 4000);


        // HOUR SLIDER ///////////////////////////////////////////////////////////////////////////////////
        var data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24];

        var sliderStep = d3
            .sliderBottom()
            .min(1)
            .max(24)
            .width(300)
            .height(50)
            .tickFormat(data => int_to_time_text(data))
            .ticks(6)
            .step(1)
            .default(1)
            .on('onchange', val => {
                hourly_timer.stop()
                    // d3.select('p#value-step').text(d3.format('.2%')(val));
                d3.select('p#value-step').text(int_to_time_text(val));
                // Call the function we want to change here
                // Update the area chart
                update_area(val)
                    // Update the plants
                update_plants(val)
                    // update flows
                    // update_flows(val)
            });

        var gStep = d3
            .select('div#slider-step')
            .append('svg')
            .attr('width', 300)
            .attr('height', 50)
            .append('g')
            .attr('transform', 'translate(300,10)');

        gStep.call(sliderStep);
        d3.select('p#value-step').text(int_to_time_text(sliderStep.value()));

        let hour_for_update = 1;

        let update_hourly = function(e) {
            if (hour_for_update > 24) {
                hour_for_update = 1;
            }
            update_area(hour_for_update)
            update_plants(hour_for_update)
            hour_for_update++;
        }

        var hourly_timer = d3.interval(update_hourly, 500);


    }
</script>